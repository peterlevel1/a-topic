var fs = require('fs');
var path = require('path');
var util = require('util');

var t = require('t');
var fo = require('fo');
var async = fo._;

var rCommonjsRequire = /require\s*\(\s*["']([^'"\s]+)["']\s*\)/g;
var pSlice = Array.prototype.slice;

function getRequireArgs(str) {
	str = (str + '')
		.replace(t.utils.rscriptCommentLine, '')
		.replace(t.utils.rscriptCommentAll, '');

	return t.utils.regParts(rCommonjsRequire, str);
}

function isRelative(url) {
	return /^[.]+\//.test(url);
}

function getAbsUrl(url) {
	return path.isAbsolute(url)
		? url
		: path.join(__dirname, url);
}

function error(err) {
	throw err;
}

function noop() {}

function Node(opts) {
	var self = this;
	t.extend(self, opts);

	if (!self.done) {
		throw new Error('Node: no done callback');
	} else {
		self.done = self.done.bind(self);
	}

	if (!self.fail) {
		self.fail = error;
	} else {
		self.fail = self.fail.bind(self);
	}

	self.loading = true;
	self.loaded = false;
}

Node.setDescription = function () {
	Node.desc = {
		paths : {},
		pkgUrls : {},
		baseUrl : '',
		filenames : {},
		dirnames : {},
		textContents : {}
	};
}

Node.getFd = function (url) {
	url = t.utils.trim(url);
	var fd = {};
	fd.url = url;
	fd.isRelative = isRelative(url);
	fd.isAbsolute = path.isAbsolute(url);
	fd.onlyName = !fd.isRelative && !/\//.test(url);
	return fd;
};

Node.getStat = function (url, callback) {
	fs.stat(url, function (err, stat) {
		if (err == null) {
			return callback(null, url, stat);
		}

		if (/\.(js|json)$/.test(url)) {
			return callback(new Error('getStat: wrong url: ' + url));
		}

		fs.stat(url + '.js', function (err, stat) {
			if (err == null) {
				return callback(null, url + '.js', stat);
			}

			fs.stat(path.join(url, 'index.js'), function (err, stat) {
				if (err == null) {
					return callback(null, path.join(url, 'index.js'), stat);
				}

				return callback(new Error('getStat: wrong url: ' + url));
			});
		});
	});
};

// require()
// a file with ./ ../, and
// a file which is
Node.figourOutUrl = function (url, baseUrl, desc) {
	var fd = Node.getFd(url);
	url = fd.url;

	if (fd.isAbsolute) {
		return url;
	}

	//look for a mapped url
	if (!fd.isRelative && desc) {
		if (fd.onlyName && desc.pkgUrls[url]) {
			url = desc.pkgUrls[url];
		} else if (desc.paths[url]) {
			url = desc.paths[url];
		} else {
			throw new Error('handleChilrenUrls: ' + url + ' not mapped');
		}

		if (path.isAbsolute(url)) {
			return url;
		} else if (desc.baseUrl) {
			return path.join(desc.baseUrl, url);
		} else {
			throw new Error('handleChilrenUrls: no desc.baseUrl !');
		}
	}

	return path.join(baseUrl, url);
};

Node.prototype.collectChildren = function () {
	var self = this;

	if (self.loading === true ||
		!self.children ||
		!self.children.length) {
		return;
	}
	self.loading = true;
	var isDirectory = self.isDirectory;
	var baseUrl = self.baseUrl;

	async.series(
		self.children,
		function (url, next) {
			if (!isDirectory) {
				url = self.figourOutUrl(url);
			}
			self.handleSingleUrl(url, next);
		},
		function (err, children) {
			if (err) {
				return self.fail(err);
			}

			self.children = children;
			self.loading = false;
			self.loaded = true;
			self.done();
			self.done = null;
			self.fail = null;
		}
	);
};

Node.prototype.handleSingleUrl = function (url, next) {
	var self = this;
	Node.getStat(url, function (err, url, stat) {
		if (err) {
			return next(err);
		}

		if (stat.isDirectory()) {
			fo.readdir(url)
				.then(function (filenames) {
					var dir = new Dir({
						dirname : url,
						filenames : filenames.map(function (filename) {
							return path.join(url, filename);
						}),
						done : function () {
							next(null, dir);
						}
					});
				}, next);
		} else if (stat.isFile()) {
			fo.readFile([url, 'utf8'])
				.then(function (textContent) {
					var file = new File({
						filename : url,
						textContent : textContent,
						done : function () {
							next(null, file);
						}
					});
				}, next);
		} else {
			next(new Error('collectChildren: unkown file info: ' + url));
		}
	});
}

function Dir(opts) {
	Node.call(this, opts);
	this.isFile = false;
	this.isDirectory = true;
	this.baseUrl = this.dirname;
	this.children = this.filenames || [];

	if (!this.children.length) {
		this.loading = false;
		this.loaded = true;
		this.done();
	} else {
		var baseUrl = this.baseUrl;
		this.children = this.children.map(function (one) {
			return path.join(baseUrl, one);
		});
		this.collectChildren();
	}
}
util.inherits(Dir, Node);


function File(opts) {
	Node.call(this, opts);

	this.isFile = true;
	this.isDirectory = false;
	this.baseUrl = path.dirname(this.filename);

	var children;
	if (this.textContent) {
		children = getRequireArgs(opts.textContent);
		if (t.extend.isArrayLike(children)) {
			this.children = children.map(function (one) {
				return one[1];
			});
		}
	}

	if (!this.children || !this.children.length) {
		this.loading = false;
		this.loaded = true;
		this.done();
	} else {
		this.collectChildren();
	}
}
util.inherits(File, Node);

File.prototype.figourOutUrl = function (url) {
	return Node.figourOutUrl(url, this.baseUrl, Node.desc);
}

// a nodejs module -> single file;
var packer = {
	modules : {},
	pack : function (opts) {
		if (opts.target && path.isAbsolute(opts.target)) {

			Node.getStat(opts.target, function (err, url, stat) {
				if (err) {
					throw err;
				}

				if (!stat.isDirectory()) {
					return console.log('not a dir');
				}

				Node.setDescription();
				var desc = Node.desc;

				fo.walkdir(
					url,
					function (file, next) {
						next();
					},
					function (dir) {
						data.dirs.push({

						});
					},
					function (err) {
						console.log(err || 'done');
						console.log(data);
					}
				);
			});
		}
	}
};
module.exports = packer;