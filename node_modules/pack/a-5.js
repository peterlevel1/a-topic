var fs = require('fs');
var path = require('path');
var util = require('util');

var t = require('t');
var fo = require('fo');
var async = fo._;

var rCommonjsRequire = /require\s*\(\s*["']([^'"\s]+)["']\s*\)/g;
var pSlice = Array.prototype.slice;

function getRequireArgs(str) {
	str = (str + '')
		.replace(t.utils.rscriptCommentLine, '')
		.replace(t.utils.rscriptCommentAll, '');

	return t.utils.regParts(rCommonjsRequire, str);
}

function isRelative(url) {
	return /^[.]+\//.test(url);
}

function getFd(url) {
	url = t.utils.trim(url);
	var fd = {};
	fd.url = url;
	fd.isRelative = isRelative(url);
	fd.isAbsolute = path.isAbsolute(url);
	fd.onlyName = !fd.isRelative && !/\//.test(url);
	return fd;
}

function getAbsUrl(url) {
	return path.isAbsolute(url)
		? url
		: path.join(__dirname, url);
}

function error(err) {
	throw err;
}

function noop() {}

function Node(opts) {
	var self = this;
	t.extend(self, opts);

	if (!self.done) {
		throw new Error('Node: no done callback');
	} else {
		self.done = self.done.bind(self);
	}

	if (!self.fail) {
		self.fail = error;
	} else {
		self.fail = self.fail.bind(self);
	}

	self.loading = true;
	self.loaded = false;
}

Node.paths = {};
Node.pkgUrls = {};
Node.baseUrl = '';

// require()
// a file with ./ ../, and
// a file which is
Node.prototype.figourOutUrl = function (url) {
	if (this.loaded) {
		return callback(new Error('handleChilrenUrls: already loaded'));
	}
	var baseUrl = this.baseUrl;
	var fd = getFd(url);
	var url = fd.url;

	if (fd.isAbsolute) {
		return url;
	}

	//look for a mapped url
	if (!fd.isRelative) {
		if (fd.onlyName && Node.pkgUrls[url]) {
			url = Node.pkgUrls[url];
		} else if (Node.paths[url]) {
			url = Node.paths[url];
		} else {
			throw new Error('handleChilrenUrls: ' + url + ' not mapped');
		}

		if (path.isAbsolute(url)) {
			return url;
		} else if (Node.baseUrl) {
			return path.join(Node.baseUrl, url);
		} else {
			throw new Error('handleChilrenUrls: no Node.baseUrl !');
		}
	}

	return path.join(baseUrl, url);

}

Node.prototype.collectChildren = function () {
	var self = this;

	if (self.loading === true ||
		!self.children ||
		!self.children.length) {
		return;
	}
	self.loading = true;
	var isDirectory = self.isDirectory;
	var baseUrl = self.baseUrl;

	async.series(
		self.children,
		function (url, next) {
			if (!isDirectory) {
				url = !path.isAbsolute(url)
					? path.join(baseUrl, url)
					: url;
			}

			self.handleSingleUrl(url, next);
		},
		function (err, children) {
			if (err) {
				return self.fail(err);
			}

			self.children = children;
			self.loading = false;
			self.loaded = true;
			self.done();
			self.done = null;
			self.fail = null;
		}
	);
};

Node.getStat = function (url, callback) {
	fs.stat(url, function (err, stat) {
		if (err == null) {
			return callback(null, url, stat);
		}

		if (/\.(js|json)$/.test(url)) {
			return callback(new Error('getStat: wrong url: ' + url));
		}

		fs.stat(url + '.js', function (err, stat) {
			if (err == null) {
				return callback(null, url + '.js', stat);
			}

			fs.stat(path.join(url, 'index.js'), function (err, stat) {
				if (err == null) {
					return callback(null, path.join(url, 'index.js'), stat);
				}

				return callback(new Error('getStat: wrong url: ' + url));
			})
		})
	})
}

Node.prototype.handleSingleUrl = function (url, next) {
	var self = this;
	Node.getStat(url, function (err, url, stat) {
		if (err) {
			return next(err);
		}

		if (stat.isDirectory()) {
			fo.readdir(url)
				.then(function (filenames) {
					var dir = new Dir({
						dirname : url,
						filenames : filenames.map(function (filename) {
							return path.join(url, filename);
						}),
						done : function () {
							next(null, dir);
						}
					});
				}, next);
		} else if (stat.isFile()) {
			fo.readFile([url, 'utf8'])
				.then(function (textContent) {
					var file = new File({
						filename : url,
						textContent : textContent,
						done : function () {
							next(null, file);
						}
					});
				}, next);
		} else {
			next(new Error('collectChildren: unkown file info: ' + url));
		}
	});
}

function Dir(opts) {
	Node.call(this, opts);
	this.isFile = false;
	this.isDirectory = true;
	this.baseUrl = this.dirname;
	this.children = this.filenames || [];

	if (!this.children.length) {
		this.loading = false;
		this.loaded = true;
		this.done();
	} else {
		var baseUrl = this.baseUrl;
		this.children = this.children.map(function (one) {
			return path.join(baseUrl, one);
		});
		this.collectChildren();
	}
}
util.inherits(Dir, Node);


function File(opts) {
	Node.call(this, opts);

	this.isFile = true;
	this.isDirectory = false;
	this.baseUrl = path.dirname(this.filename);

	var children;
	if (this.textContent) {
		children = getRequireArgs(opts.textContent);
		if (t.extend.isArrayLike(children)) {
			this.children = children.map(function (one) {
				return one[1];
			});
		}
	}

	if (!this.children || !this.children.length) {
		this.loading = false;
		this.loaded = true;
		this.done();
	} else {
		this.collectChildren();
	}
}
util.inherits(File, Node);

// a nodejs module -> single file;
var packer = {
	modules : {},
	pack : function (opts) {
		// a file or
		// a dir with (dir.js || dir + index.js)
		if (opts.target && path.isAbsolute(opts.target)) {

			Node.getStat(opts.target, function (err, url, stat) {
				console.log(err);
				console.log(url);
				console.log(stat.isDirectory());
				console.log(stat.isFile());

				if (stat.isDirectory()) {
					var data = { files : [], dirs : [] };
					fo.walkdir(
						url,
						function (file, next) {
							next();
						},
						function (dir) {
							data.dirs.push({

							});
						},
						function (err) {
							console.log(err || 'done');
							console.log(data);
						}
					);
				}
			});

			// var file = new File({
			// 	filename : opts.target,
			// 	textContent : fs.readFileSync(opts.target, 'utf8'),
			// 	done : function () {
			// 		console.log('done');
			// 	}
			// });
			// console.log(file);
			// file.collectChildren(function (err, children) {
			// 	console.log(err, children);
			// });
		}
	}
};
module.exports = packer;